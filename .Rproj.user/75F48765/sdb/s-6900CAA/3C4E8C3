{
    "collab_server" : "",
    "contents" : "# CLI versus IDE {#clivside}\n\nR is not only a package for statistical analysis, it is indeed a complete **general-purposed language**. This is exactly why it is so powerful and flexible compared to other statistical packages such as `SAS`, `Stata`, `RATS`, or even `SPSS`. But this is also why it's harder to learn compared to the above packages.\n\nTo develop your analytics via the R language, i.e., to use R, you may either work under a **C**ommand-**L**ine **I**nterface or an **I**ntegrated **D**evelopment **E**nviornment.\n\n## CLI (Command-Line Interface)\n\nOnce R is installed on your machine, you can use the CLI to execute R in either interactive mode or batch mode. \n\n### For Windows User\nThe CLI on Windows is generally represented by the built-in `cmd.exe`. Unfortunately it is not user-friendly so please just ignore it. A more viable choice is to use `RGui.exe`. It is actually not just a CLI but a minimal IDE to use R. \n\nThe GUI of `RGui.exe` contains a CLI for user to use the R language interactively, and optionally one or multiple text editors to edit Rscript. The beauty of it is that you can select part or all of a Rscript to send to the CLI for execution, and immediately get the result printed. \n\n### For OS X (Mac) User\nThe CLI on OS X is generally represented by the built-in `Terminal.app`. To use R under the terminal just type \"R\" and hit enter. A welcome message will be immediately printed, followed by a *command prompt* (`>`) waiting for further instruction in the R language:\n\n```\nR version 3.2.0 (2015-04-16) -- \"Full of Ingredients\"\nCopyright (C) 2015 The R Foundation for Statistical Computing\nPlatform: x86_64-apple-darwin13.4.0 (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n> \n```\n\n### For Linux User\nOpen a terminal, type \"R\" and hit enter. There you are.\n\n## IDE (Integrated Development Environment)\n\nCLI is useful to quickly check result of light-weighted R codes. But it is not suitable for more complex development needs. To flexibly develop your analytics via the R language, an IDE is highly recommended.\n\n### RStudio\n[RStudio](http://www.rstudio.com) is a powerful IDE specifically designed for the R language, supported multiple platform. It is strongly recommended that user new to the R language uses RStudio as the main tool to explore the potentials of R.\n\n### RStudio Server\nFor Linux user, there is also a server version of RStudio. It allows users to use the IDE over a web browser. That is, users can access remote machine with R and RStudo Server properly installed.\n\n## Interactive v.s. Batch Mode\n\n**[Notice: this section is mainly written for \\*nix system.]**\nWhen one is in the R language command prompt, one is in the interactive mode. A production-ready script is usually executed in batch mode, while in other cases like doing data exploration or iterative analytics, the interactive mode will be more appropriate. Even though a R program (or Rscript, interchangeably) is designed to be run in batch mode, it is probably developed and even tested mainly in interactive session.\n\n### Parsing Command Line Arguments\nWhen running a Rscript in batch mode, it is possible to parse additional arguments given along with the command line. The arguments can be parsed by the function `commandArgs`. Consider the following example, assumed a file name of `parse-cmdarg.R`:\n\n```{r eval=FALSE}\n#!/usr/bin/env Rscript\n\nfcmdargs <- commandArgs()\nscript_name <- basename(fcmdargs[grepl(\"--file\", fcmdargs)])\ncmdargs <- commandArgs(trailingOnly=TRUE)\nmessage(\"The script name is: \", script_name)\ni <- 0\nfor ( arg in cmdargs ) {\n  i <- i + 1\n  message(sprintf(\"Argument %s: %s\", i, arg))\n}\n```\n\nRun the above script by something like `./parse-cmdarg.R arg1 arg2 arg3` should give the following result:\n\n```sh\nThe script name is: parse-cmdarg.R\nArgument 1: arg1\nArgument 2: arg2\nArgument 3: arg3\n```\n\nEven when in interactive mode one can use `commandArgs` to get the underlying arguments given. This is true because an interactive R session is also initiated by a command line, which in turn can have its own command line arguments.\n\n### Interactive or Not Interactive?\nOne can use the function `interactive` to check if the current session is in interactive or batch mode. The function returns `TRUE` when the current session is indeed interactive; otherwise it returns `FALSE`. This can be handy if the main program is for batch processing but one needs to debug it interactively. For example, considering the following Rscript `add-one.R`:\n\n```{r eval=FALSE}\n#!/usr/bin/env Rscript\n\ncmdargs <- commandArgs(trailingOnly=TRUE)\nas.integer(cmdargs[1]) + 1\n```\n\nThe program simply add the first command line argument by one and print the result. Run `./add-one.R 1` will give a result of:\n\n```\n[1] 2\n```\n\nBut what if we don't supply any argument? What if an argument other than number is used? Since this script is tiny, one can easily test these scenarios under CLI, say, `./add-one.R` or `./add-one.R foo` to realize the possible consequences and make corresponding modification, In reality the main program can be large in size and the consequences of unexpected command line arguments are not easily forseen. Let's try modifying the `add-one.R` program in the following manner:\n\n```{r eval=FALSE}\n#!/usr/bin/env Rscript\n\nif ( interactive() ) {\n  cmdargs <- \"anything to be tested\"\n} else {\n  cmdargs <- commandArgs(trailingOnly=TRUE)\n}\nas.integer(cmdargs[1]) + 1\n```\n\nNow one can simulate the argument given in command line, even if the current session is interactive. What one's doing is to change the string \"anything to be tested\" to anything one can imagine to test the behavior of this BATCH program, INTERACTIVELY. Notice that the modified program will behave totally the same in batch mode. The modification just makes it easier to be tested under interactive session.\n\n### Shabang `#!`\nOne should notice that all the above Rscripts contain a first line starting in `#!`. This is a unix convention sometimes called \"shabang\" to mark the process name that should be used to execute the script. Should one choose not to declare the shabang line, the script can still be executed, but the command line must be explicit:\n\n```\nRscript parse-cmdarg.R some_args\n```\n\nrather than:\n\n```\n./parse-cmdarg.R some_args\n```\n\nAlso, it is the unix-way to prepend the `./` to the file that is to be executed, provided that the file is executable. One should use `chmod +x your_rscript.R` to mark one's script to be executable, as long as that script is expected to serve in batch mode.\n\n\n",
    "created" : 1460355154691.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "488389156",
    "id" : "3C4E8C3",
    "lastKnownWriteTime" : 1460365819,
    "last_content_update" : 1460365819471,
    "path" : "~/gitrepo/rbasic/02-cli-vs-ide.Rmd",
    "project_path" : "02-cli-vs-ide.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}