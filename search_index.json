[
["index.html", "RBasic 101 Chapter 1 Prologue 1.1 Thought Experiments 1.2 Welcome to the R Language", " RBasic 101 Kyle Chung 2016-04-27   Chapter 1 Prologue The materials of this book target at new users or users not very familiar with R. Before you start to read this book, take a look at the following examples to test your familiarity with the R language.  1.1 Thought Experiments  1.1.1 First Trial A &lt;- 1 + 1 (B &lt;- 1 + 1) ## [1] 2 identical(A, B) ## [1] TRUE Now you know that adding parenthesis around an expression will force R to print the result of it. But why? If you immediately type ?&quot;(&quot; to search for a possible anwser, you are probably not new to the R language. And if you can further read the document and get yourself understood, you are not the targeted reader of this book.   1.1.2 Second Trial a_vec &lt;- 1:2 names(a_vec) ## NULL names(a_vec) &lt;- c(&quot;foo&quot;, &quot;bar&quot;) names(a_vec) ## [1] &quot;foo&quot; &quot;bar&quot; The function names is used to return the names of the object given, if any. In the third line we also use names to rename the object. Now you know that we can use such tech to rename an object. But how is it possible to asign a value to the returned value of a function? Should you really think it is okay to do so, then think about the following codes: xf &lt;- function(x) x xf(1) &lt;- 2 ## Error in xf(1) &lt;- 2: target of assignment expands to non-language object Oops! Acutally you can’t do that. Asign a value to the returned value of a function causes an error. But names(a_vec) &lt;- c(&quot;foo&quot;, &quot;bar&quot;) does work, right? If you do understand the reason why it actually works, you are not the targeted reader of this book.   1.1.3 Third Trial `+`(1, 2) ## [1] 3 You may never see this coming before, or you just don’t code in such style, but you do understand this is a function call to the add function, in a functional way. That say, you are completely comfortable about the following codes: for ( op in c(`+`, `-`, `*`, `/`) )   print(op(10, 2)) ## [1] 12 ## [1] 8 ## [1] 20 ## [1] 5 Then you are not the targeted reader of this book.    1.2 Welcome to the R Language If all the above examples bother you nothing, you are not the targeted reader of this book since you are quite familiar with the R language and you do know how to dive depper on your own. But if some or all of the above examples make you confused or starting googling, you can learn from this book. This book is NOT a HOW-TO cookbook to teach you how to write in the R language. A HOW-TO cookbook will let you know, in the R language, how to force print an expression, or rename an object. This book is NOT a HOW-TO cookbook. Yes we can use ( to force print an expression. But why? Yes we can use names to rename an object. But why? This book is to teach you WHY we write R in this or that way. Consequently you are not just coding in R, you are also thinking in R. And that’s where the R language starts to shine.   "],
["install.html", "Chapter 2 Installation 2.1 R Installation 2.2 R Package Installation", " Chapter 2 Installation R is open-sourced and can be installed on operating systems such as Windows, OS X, or many other Linux/Unix distributions. This chapter describes the recommended way to install R and R packages across different platform.  2.1 R Installation  2.1.1 Windows The best way to install R on a Windows PC is to download the binary executable from CRAN. Click through “Download R for Windows” and “install R for the first time” to get the file. For example, the latest stable version is R-3.2.4revised-win.exe when this chapter was written. One can also find older versions of R under the CRAN’s /bin/windows/base/old folder. The installation of R for Windows from the above executable file will also include a GUI tool called RGui.exe for interactive development purpose.   2.1.2 OS X (Mac) The best way to install R on a Mac is to download the binary package file from CRAN. Click through “Download R for (Mac) OS X” and download the latest stable version. For example, the latest stable version is R-3.2.4.pkg when this chapter was written. One can also find older versions of R under the CRAN’s /bin/macosx/base/old folder. The installation of R for Mac from the above pacakge file will also include a GUI tool called R.app for interactive development purpose.   2.1.3 Ubuntu There are many ways to get R installed on a Linux box. Here we use Ubuntu as an example. Naturally one would probably like to check if there is already available compiled package from any repository of your distribution. To do so, use sudo apt-cache policy r-base and something like the following may return: r-base:   Installed: (none)   Candidate: 3.0.2-1ubuntu1   Version table:      3.0.2-1ubuntu1 0         500 http://mirrors.digitalocean.com/ubuntu/ trusty/universe amd64 Packages But generally the compiled version on Ubuntu default repository won’t catch up with the latest one on CRAN. If it is okay to install the older version of R then all the things left to do is a simple sudo apt-get install r-base. However, if one would like to install the latest stable version of R, a mirror of CRAN must be setup. This is documented in details under CRAN’s bin/linux/ubuntu/ folder. For Ubuntu 14.04, add deb https://&lt;my.favorite.cran.mirror&gt;/bin/linux/ubuntu trusty/ to /etc/apt/sources.list, where &lt;my.favorite.cran.mirror&gt; should be replaced with one of the preferred mirrors from CRAN’s mirror list. One choice is the NTU mirror so the added line to the sources.list file will be: deb https://http://cran.csie.ntu.edu.tw//bin/linux/ubuntu trusty/ After this is done, use sudo apt-get update to update the package manager and use sudo apt-get install r-base to install the latest version of R. You may also like to do sudo apt-get install r-base-dev to further install developer’s tools. If there is any error concerning the secure key issue, consult the “Secure APT” section for solution.   2.1.4 Update the R Installation It is recommended to directly install the newer version of R, if wanted. Each version of R is separately maintained in the installed system. Of course the newer R will come with only built-in packages. It is recommended that users re-install all the packages wanted from the newer R.    2.2 R Package Installation  2.2.1 From the Internet  2.2.1.1 CRAN The most convenient way to install R package is to use the install.packages function. By default it will install the specified package from CRAN: The Comprehensive R Archive Network. For Mac and Windows users usually the desired package is already compiled and can be readily install in seconds. For Linux users the install.packages still works but the package will be compiled from its source code. For example, to install the powerful data.table package: install.packages(&quot;data.table&quot;) The function automatically resolve dependency issue, so any dependent packages will also be installed, if any. One can also uninstall a package by using the function remove.packages.   2.2.1.2 GitHub Not all packages are available at CRAN. And there are more and more developers prefer to host their source codes on platform like GitHub. Sometimes a package can be found in both CRAN and GitHub but the latest developing version is only available at GitHub. To directly install a package from its GitHub repository, use the function devtools::install_github. One must first install the package devtools. For Windows users, additional dependency on the Rtools is required before installing devtools. For Mac users, the XCode command line tool may be required. Firstly install XCode; then open Terminal.app and type xcode-select --install. To install package from GitHub, the name for the repo must be specified. For example, to install the package ArgParser from the book author’s repo: devtools::install_github(&quot;everdark/ArgParser&quot;)    2.2.2 From Local Source or Binary Source codes of R packages is stored as tar.gz. Binaries are stored as .zip for Windows and .tgz for Mac OS X. It may happens that users want to directly install the package from these files locally. This can also be achieved by install.packages, by specifying argument repos=NULL and point pkgs to the full path of those files. For example: install.packages(&quot;ggplot2_2.1.0.zip&quot;, repos=NULL)    "],
["clivside.html", "Chapter 3 CLI versus IDE 3.1 CLI (Command-Line Interface) 3.2 IDE (Integrated Development Environment) 3.3 Interactive v.s. Batch Mode", " Chapter 3 CLI versus IDE R is not only a package for statistical analysis, it is indeed a complete general-purposed language. This is exactly why it is so powerful and flexible compared to other statistical packages such as SAS, Stata, RATS, or even SPSS. But this is also why it’s harder to learn compared to the above packages. To develop your analytics via the R language, i.e., to use R, you may either work under a Command-Line Interface or an Integrated Development Enviornment.  3.1 CLI (Command-Line Interface) Once R is installed on your machine, you can use the CLI to execute R in either interactive mode or batch mode.  3.1.1 For Windows User The CLI on Windows is generally represented by the built-in cmd.exe. Unfortunately it is not user-friendly so please just ignore it. A more viable choice is to use RGui.exe. It is actually not just a CLI but a minimal IDE to use R. The GUI of RGui.exe contains a CLI for user to use the R language interactively, and optionally one or multiple text editors to edit Rscript. The beauty of it is that you can select part or all of a Rscript to send to the CLI for execution, and immediately get the result printed.   3.1.2 For OS X (Mac) User The CLI on OS X is generally represented by the built-in Terminal.app. To use R under the terminal just type “R” and hit enter. A welcome message will be immediately printed, followed by a command prompt (&gt;) waiting for further instruction in the R language: R version 3.2.0 (2015-04-16) -- &quot;Full of Ingredients&quot; Copyright (C) 2015 The R Foundation for Statistical Computing Platform: x86_64-apple-darwin13.4.0 (64-bit)  R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under certain conditions. Type &#39;license()&#39; or &#39;licence()&#39; for distribution details.    Natural language support but running in an English locale  R is a collaborative project with many contributors. Type &#39;contributors()&#39; for more information and &#39;citation()&#39; on how to cite R or R packages in publications.  Type &#39;demo()&#39; for some demos, &#39;help()&#39; for on-line help, or &#39;help.start()&#39; for an HTML browser interface to help. Type &#39;q()&#39; to quit R.  &gt;    3.1.3 For Linux User Open a terminal, type “R” and hit enter. There you are.    3.2 IDE (Integrated Development Environment) CLI is useful to quickly check result of light-weighted R codes. But it is not suitable for more complex development needs. To flexibly develop your analytics via the R language, an IDE is highly recommended.  3.2.1 RStudio RStudio is a powerful IDE specifically designed for the R language, supported multiple platform. It is strongly recommended that user new to the R language uses RStudio as the main tool to explore the potentials of R.   3.2.2 RStudio Server For Linux user, there is also a server version of RStudio. It allows users to use the IDE over a web browser. That is, users can access remote machine with R and RStudo Server properly installed.    3.3 Interactive v.s. Batch Mode [Notice: this section is mainly written for *nix system.] When one is in the R language command prompt, one is in the interactive mode. A production-ready script is usually executed in batch mode, while in other cases like doing data exploration or iterative analytics, the interactive mode will be more appropriate. Even though a R program (or Rscript, interchangeably) is designed to be run in batch mode, it is probably developed and even tested mainly in interactive session.  3.3.1 Parsing Command Line Arguments When running a Rscript in batch mode, it is possible to parse additional arguments given along with the command line. The arguments can be parsed by the function commandArgs. Consider the following example, assumed a file name of parse-cmdarg.R: #!/usr/bin/env Rscript  fcmdargs &lt;- commandArgs() script_name &lt;- basename(fcmdargs[grepl(&quot;--file&quot;, fcmdargs)]) cmdargs &lt;- commandArgs(trailingOnly=TRUE) message(&quot;The script name is: &quot;, script_name) i &lt;- 0 for ( arg in cmdargs ) {   i &lt;- i + 1   message(sprintf(&quot;Argument %s: %s&quot;, i, arg)) } Run the above script by something like ./parse-cmdarg.R arg1 arg2 arg3 should give the following result: The script name is: parse-cmdarg.R Argument 1: arg1 Argument 2: arg2 Argument 3: arg3 Even when in interactive mode one can use commandArgs to get the underlying arguments given. This is true because an interactive R session is also initiated by a command line, which in turn can have its own command line arguments.   3.3.2 Interactive or Not Interactive? One can use the function interactive to check if the current session is in interactive or batch mode. The function returns TRUE when the current session is indeed interactive; otherwise it returns FALSE. This can be handy if the main program is for batch processing but one needs to debug it interactively. For example, considering the following Rscript add-one.R: #!/usr/bin/env Rscript  cmdargs &lt;- commandArgs(trailingOnly=TRUE) as.integer(cmdargs[1]) + 1 The program simply add the first command line argument by one and print the result. Run ./add-one.R 1 will give a result of: [1] 2 But what if we don’t supply any argument? What if an argument other than number is used? Since this script is tiny, one can easily test these scenarios under CLI, say, ./add-one.R or ./add-one.R foo to realize the possible consequences and make corresponding modification, In reality the main program can be large in size and the consequences of unexpected command line arguments are not easily forseen. Let’s try modifying the add-one.R program in the following manner: #!/usr/bin/env Rscript  if ( interactive() ) {   cmdargs &lt;- &quot;anything to be tested&quot; } else {   cmdargs &lt;- commandArgs(trailingOnly=TRUE) } as.integer(cmdargs[1]) + 1 Now one can simulate the argument given in command line, even if the current session is interactive. What one’s doing is to change the string “anything to be tested” to anything one can imagine to test the behavior of this BATCH program, INTERACTIVELY. Notice that the modified program will behave totally the same in batch mode. The modification just makes it easier to be tested under interactive session.   3.3.3 Shabang #! One should notice that all the above Rscripts contain a first line starting in #!. This is a unix convention sometimes called “shabang” to mark the process name that should be used to execute the script. Should one choose not to declare the shabang line, the script can still be executed, but the command line must be explicit: Rscript parse-cmdarg.R some_args rather than: ./parse-cmdarg.R some_args Also, it is the unix-way to prepend the ./ to the file that is to be executed, provided that the file is executable. One should use chmod +x your_rscript.R to mark one’s script to be executable, as long as that script is expected to serve in batch mode.    "],
["data-struc.html", "Chapter 4 Data Structures and Types 4.1 Atomic Vector 4.2 Recursive Vector 4.3 Special Values", " Chapter 4 Data Structures and Types There is no scalar in R. There is no scalar in R. There is no scalar in R. Every structure is of vector form. A (seemingly) scalar is indeed a vector of length 1. This is a striking concept compared to other general-purposed language or statistical packages. It turns out that the fact won’t affect mush about how to code R, but the understanding of such concept is helpful for better coding thinking in the R language. Compared to other general-purposed language, the built-in data structures are not rich in R. But they are considerably flexible. Most of the analytics can be fulfilled based on the minimal set of these structures. All structures are vectors in R. And there are two types of vector: atomic and recursive. This chapter will quickly go through both of them.  4.1 Atomic Vector  Common types of atomic vector include: numeric, character, logical, and factor.  Atomic vector is the foundamental data structure in R. It is called atomic because it can only contain the same type of data and no nesting allowed. For example: 1 ## [1] 1 The number 1 is a vector (of length 1, so it looks like a scalar but yes it is a vector). To check the type of a vector one can use the function typeof: typeof(1) ## [1] &quot;double&quot; The result of typeof reveals that the storage mode of the vector 1 is double; hence the vector is a numeric vector. There are many bulit-in functions to manipulate numeric vector. Some examples follow: 1:5 ## [1] 1 2 3 4 5 seq(5, 1, -1) ## [1] 5 4 3 2 1 c(1, 1, 2, 3, 5) ## [1] 1 1 2 3 5 rep(777, 3) ## [1] 777 777 777 One can also use integer, numeric, character, and logical as a creation function to create vectors of corresponding type, with the argument to be the desired length of the created vector: integer(3)    # default value is 0L ## [1] 0 0 0 numeric(3)    # default value is 0 ## [1] 0 0 0 character(3)  # default value is &quot;&quot; (empty string) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; logical(3)    # default value is FALSE ## [1] FALSE FALSE FALSE Normally a number will be associated with type double. To force R use integer type (it use considerably less storage space compared to a double), just append L to the number: typeof(1:5L) ## [1] &quot;integer&quot; Since an atomic vector is, atomic, it has no nesting structure: c(1:5, seq(5, 1, -1), c(1, 1, 2, 3, 5)) ##  [1] 1 2 3 4 5 5 4 3 2 1 1 1 2 3 5 The result of concatenation of multiple atomic vectors is one single atomic vector, not a vector nested with three different vectors. Does this mean that atomic vectors of different types can not be combined? Not necessary. num_vec &lt;- 1:3 str_vec &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) c(num_vec, str_vec) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; When a numeric vector and a character vector combine, the resulting atomic vector is of type character. Such behavior is called type coercion and is a very important concept in most programming languages. Coercion always occurs when different types of atomic vectors are combined. The principle of coercion is to minimize information loss, if any. For example, when a logical vector combined with a numeric: num_vec &lt;- 1:3 # here one uses &quot;&lt;-&quot;&quot; to asign a value to an object bol_vec &lt;- c(TRUE, FALSE, FALSE) # or c(T, F, F) but not recommended typeof(c(num_vec, bol_vec)) ## [1] &quot;integer&quot; logicals are coerced into integer. More examples on coercion: typeof(c(1, 2L)) ## [1] &quot;double&quot; typeof(c(1L, TRUE)) ## [1] &quot;integer&quot; typeof(c(1.0, TRUE)) ## [1] &quot;double&quot; typeof(c(1.0, TRUE, &quot;foo&quot;)) ## [1] &quot;character&quot; In addition to coercion, one can also explicitly convert one type to another. This is done by the function family as. For example, to convert logicals into integers and vice versa: as.logical(-1:2L) ## [1]  TRUE FALSE  TRUE  TRUE as.integer(c(TRUE, FALSE, FALSE)) ## [1] 1 0 0 Notice that when casting integers to logicals, all the non-zeroes are converted to TRUE, only 0s are converted to FALSE.  4.1.1 General Operations on Vectors  4.1.1.1 Subseting Vectors can be subset by using the bracket syntax. vv &lt;- 10:1 vv[1:2] ## [1] 10  9 vv[c(1, 3, 5)] ## [1] 10  8  6 vv[rep(3, 5)] ## [1] 8 8 8 8 8 The bracket accepts another vector as a selection vector. If the selection vector is of type numeric, the original vector is to be selected based on numerical index. Any non-integer will be floored so the result of c(1:10)[c(1.1, 1.9)] is 1, 1. Since the bracket accepts vectors, one can also use logical vector for subsetting: vv &lt;- 3:1 vv[c(TRUE, FALSE, FALSE)] ## [1] 3 The fact that subsetting is done by another vector results in filtering being very easy: vv &lt;- 1:10 vv[vv &gt; 5] ## [1]  6  7  8  9 10 Since all structures are vectors, mathematical operators such as &gt; also work on vectors by nature. The result of vv &gt; 5 is an element-wise comparison and hence also a vector of the same lenght: vv &lt;- 1:10 vv &gt; 5 ##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE The resulting logical vector can then be used to subset the original vector. One can also use negative selection: vv &lt;- 1:3 vv[-3] ## [1] 1 2 vv[-length(vv)] ## [1] 1 2 vv[-(1:3)] ## integer(0) Subset a vector may resulting in missing values: vv &lt;- 1:3 vv[4] ## [1] NA Here the selection vector tries to extract the 4th element of the original vector but there is none. This will not cause any error in R; instead, the resulting vector will contains NA, which generally means a missing value.   4.1.1.2 Updating Vectors can be updated by using the bracket syntax as well. vv &lt;- 1:5 vv[1:3] &lt;- 0 vv ## [1] 0 0 0 4 5 One interesting question arises: what happen if one tried to update an element that does not exist in the vector? vv &lt;- 1:5 vv[7] &lt;- 0 vv ## [1]  1  2  3  4  5 NA  0 Two things to be noticed. First, the value will be asigned, as if it is newly created. Second, the vector will be expanded with NAs to align the new length that satisfies the updated result. How about a delete? There is no delete method in R. To effectively delete an element in a vector, use negative selection and asign the new object: # to delete the 5th element: vv &lt;- 1:5 (vv &lt;- vv[-5])  # use parenthesis to force print ## [1] 1 2 3 4 The operation of the bracket syntax is indeed functional. (Type ?&quot;[&quot; to see the document.) To understand more about what’s going on behibd the scene, one should refer to section 6.5 and also 6.6.   4.1.1.3 Naming Vectors can be named. To check the names of a vector, use the function names. To name or rename a vector, just try asign the names in a character vector to the names function call. vv &lt;- 1:3 names(vv) ## NULL names(vv) &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) str(vv) ##  Named int [1:3] 1 2 3 ##  - attr(*, &quot;names&quot;)= chr [1:3] &quot;foo&quot; &quot;bar&quot; &quot;baz&quot; If one is confused why the renaming syntax actually works, see section 6.6 for more details. Vectors can be partially named: vv &lt;- 1:3 names(vv) &lt;- c(&quot;foo&quot;, &quot;bar&quot;) names(vv) ## [1] &quot;foo&quot; &quot;bar&quot; NA Since the third element is unnamed, it is NA when calling names to print the names.    4.1.2 Common String Operations  4.1.2.1 paste Strings are called character in the R language. It’s important to know some basic string manipulation skills. One useful string function is the paste function: paste(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, sep=&#39; &#39;) ## [1] &quot;foo bar baz&quot; The function takes as many arguments as it can and concatenates them with the separator specified in the sep arguemnt. Notice that character is vector, so the paste function can operate on vector–this is called vectorization in R: paste(c(&quot;foo&quot;, &quot;bar&quot;), &quot;baz1&quot; , sep=&#39; &#39;) ## [1] &quot;foo baz1&quot; &quot;bar baz1&quot; paste(c(&quot;foo&quot;, &quot;bar&quot;), c(&quot;baz1&quot;, &quot;baz2&quot;, &quot;baz3&quot;) , sep=&#39; &#39;) ## [1] &quot;foo baz1&quot; &quot;bar baz2&quot; &quot;foo baz3&quot; What happens here is that the shorter arguments are recycled to have equal length and then each string is concatenated elment-wise. For more details about vectorization and recycling, see section 7. The paste function can also collapse a character vector into one character (a vector of length 1). This is done by using the collapse argument: paste(c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;), collapse=&#39;-&#39;) ## [1] &quot;foo-bar-baz&quot; Collapsing can also be used after concatenation. This is done by supplying more than one character vectors to paste and also specifying the collapse argument: # concatenate only paste(c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;), letters[1:5]) ## [1] &quot;foo a&quot; &quot;bar b&quot; &quot;baz c&quot; &quot;foo d&quot; &quot;bar e&quot; # concatenate and collapse paste(c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;), letters[1:5], collapse=&#39;-&#39;) ## [1] &quot;foo a-bar b-baz c-foo d-bar e&quot; There is also a variant of paste called paste0. The only difference is that paste0 use a default separator of empty string (i.e., use sep='' in paste): paste0(c(&quot;foo&quot;, &quot;bar&quot;), &quot;baz&quot;) ## [1] &quot;foobaz&quot; &quot;barbaz&quot;   4.1.2.2 sprintf Another useful function is sprintf. It is used to format a string with interpolation: sprintf(&quot;hello %s!&quot;, &quot;world&quot;) ## [1] &quot;hello world!&quot; sprintf(&quot;hello %.3f!&quot;, 7123) ## [1] &quot;hello 7123.000!&quot; sprintf(&quot;hello %i&quot;, 7) ## [1] &quot;hello 7&quot; See ?sprintf for more formatting options. Multiple interpolation is also supported, given in order: sprintf(&quot;first: %i; second: %s&quot;, 1, &quot;two&quot;) ## [1] &quot;first: 1; second: two&quot;   4.1.2.3 cat and print The cat function concatenates its arguments and print. cat(&quot;foo&quot;, c(&quot;bar&quot;, &quot;baz&quot;)) ## foo bar baz cat(&quot;foo&quot;, c(&quot;bar&quot;, &quot;baz&quot;), sep=&#39;:&#39;) ## foo:bar:baz Notice the difference between cat and paste: the former does not recycle and the result is printed; the latter does recylcing and the result is returned rather than printed. Too see this fact clear: # letters is a built-in variable storing all lower-cased English alphabets # .Last.value is another built-in variable storing the result of the last evaluation cat(letters[1:3], sep=&#39;+&#39;) ## a+b+c .Last.value ## NULL paste(letters[1:3], collapse=&#39;+&#39;) ## [1] &quot;a+b+c&quot; .Last.value ## NULL   4.1.2.4 Miscellaneous Use substr to extract partial string. Use nchar to count number of characters in a string. Use strsplit to split a string by specified separator. ss &lt;- &quot;why so serious?&quot; substr(ss, 1, 3) ## [1] &quot;why&quot; nchar(ss) ## [1] 15 strsplit(ss, split=&#39; &#39;) # the returned type is a list ## [[1]] ## [1] &quot;why&quot;      &quot;so&quot;       &quot;serious?&quot;    4.1.3 Factor Factors are special integer vectors. They are generally used to record categorical variables. It combines both features of characters and numerics, so it could be confusing for new users. Usually a factor is defined on a set of characters: baz &lt;- c(&quot;foo&quot;, &quot;bar&quot;) bazf &lt;- factor(baz) typeof(bazf) ## [1] &quot;integer&quot; str(bazf) ##  Factor w/ 2 levels &quot;bar&quot;,&quot;foo&quot;: 2 1 Notice that the typeof indicates an integer type. This is true because factors are stored internally as integers. The levels of a factor reveals the complete set of characters that could appear in the factor. Now consider a little more complicated example: baz &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;) bazf &lt;- factor(baz) levels(bazf) ## [1] &quot;bar&quot; &quot;foo&quot; When an object contains repeating samples of characters, it may be a good choice to use factor type to represent it for performance and efficiency issue, since levels only contain distinct values. levels can be manually specified when creating a factor, and levels are ordered. The order will be automatically determined if not specified. baz &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;) bazf1 &lt;- factor(baz, levels=c(&quot;bar&quot;, &quot;foo&quot;)) bazf2 &lt;- factor(baz, levels=c(&quot;foo&quot;, &quot;bar&quot;)) str(bazf1) ##  Factor w/ 2 levels &quot;bar&quot;,&quot;foo&quot;: 2 1 1 2 1 str(bazf2) ##  Factor w/ 2 levels &quot;foo&quot;,&quot;bar&quot;: 1 2 2 1 2 levels can even contain unseen values: baz &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;) bazf3 &lt;- factor(baz, levels=c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)) str(bazf3) ##  Factor w/ 3 levels &quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;: 1 2 2 1 2   4.1.4 Matrix A matrix in R is nothing more than a vector with the dim attribute. That is, a matrix is still a vector. To create a matrix one can use the matrix function: matrix(0, 3, 3) ##      [,1] [,2] [,3] ## [1,]    0    0    0 ## [2,]    0    0    0 ## [3,]    0    0    0 mm &lt;- matrix(1:9, 3, 3) str(mm) # always use the str function to check variable that you don&#39;t know for sure ##  int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 attributes(mm) ## $dim ## [1] 3 3 For now just forget about what an attribute is. One can always use dim function to check the dimension attribute of a variable: vv &lt;- 1:9 dim(vv) ## NULL A matrix can also be created by existing vector: vv &lt;- 1:9 dim(vv) &lt;- c(3,3) vv ##      [,1] [,2] [,3] ## [1,]    1    4    7 ## [2,]    2    5    8 ## [3,]    3    6    9 Here the second line creates (or replaces) the dim attribute with a 3-by-3 dimension setup.  4.1.4.1 Matrix Operations Matrices are mathematical matrices, so they can readily perform linear algebra: (vv &lt;- matrix(1:9, 3, 3)) ##      [,1] [,2] [,3] ## [1,]    1    4    7 ## [2,]    2    5    8 ## [3,]    3    6    9 # scalar product vv * 3 ##      [,1] [,2] [,3] ## [1,]    3   12   21 ## [2,]    6   15   24 ## [3,]    9   18   27 # inner product vv %*% matrix(1:6, 3, 2)  ##      [,1] [,2] ## [1,]   30   66 ## [2,]   36   81 ## [3,]   42   96 # outer products 1:9 %o% 1:9 # a more general version: see ?outer ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ##  [1,]    1    2    3    4    5    6    7    8    9 ##  [2,]    2    4    6    8   10   12   14   16   18 ##  [3,]    3    6    9   12   15   18   21   24   27 ##  [4,]    4    8   12   16   20   24   28   32   36 ##  [5,]    5   10   15   20   25   30   35   40   45 ##  [6,]    6   12   18   24   30   36   42   48   54 ##  [7,]    7   14   21   28   35   42   49   56   63 ##  [8,]    8   16   24   32   40   48   56   64   72 ##  [9,]    9   18   27   36   45   54   63   72   81    4.1.5 Array When there is more than 2 dimensions, a vector may be called an array. One can also call a matrix is a 2-dimensional array.    4.2 Recursive Vector  4.2.1 List The most important representative data structrue of recursive vector is list. A list, unlike atomic vector, can contain elements of different types, and can be nested: alist &lt;- list(1:3, c(&quot;foo&quot;, &quot;bar&quot;), paste, list(letters, month.abb)) str(alist) ## List of 4 ##  $ : int [1:3] 1 2 3 ##  $ : chr [1:2] &quot;foo&quot; &quot;bar&quot; ##  $ :function (..., sep = &quot; &quot;, collapse = NULL)   ##  $ :List of 2 ##   ..$ : chr [1:26] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ##   ..$ : chr [1:12] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; ... All the operation appliable to atomic vector is also appliable to list. A list can also be named. # slicing alist[1:3] ## [[1]] ## [1] 1 2 3 ##  ## [[2]] ## [1] &quot;foo&quot; &quot;bar&quot; ##  ## [[3]] ## function (..., sep = &quot; &quot;, collapse = NULL)  ## .Internal(paste(list(...), sep, collapse)) ## &lt;bytecode: 0x000000000781e4d0&gt; ## &lt;environment: namespace:base&gt; # replacement alist[1] &lt;- 1  # delete alist[1] &lt;- NULL  # concatenate c(alist, list(1:3)) ## [[1]] ## [1] &quot;foo&quot; &quot;bar&quot; ##  ## [[2]] ## function (..., sep = &quot; &quot;, collapse = NULL)  ## .Internal(paste(list(...), sep, collapse)) ## &lt;bytecode: 0x000000000781e4d0&gt; ## &lt;environment: namespace:base&gt; ##  ## [[3]] ## [[3]][[1]] ##  [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; ##  ## [[3]][[2]] ##  [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; ## [12] &quot;Dec&quot; ##  ##  ## [[4]] ## [1] 1 2 3 There is a little difference in indexing. The single bracket [ results in a list; the double brackets [[ results in the element itself without warpping in a list. To be clear, see the following example: alist &lt;- list(1:3, c(&quot;foo&quot;, &quot;bar&quot;), paste, list(letters, month.abb)) alist[1] ## [[1]] ## [1] 1 2 3 alist[[1]] ## [1] 1 2 3 identical(unlist(alist[1]), alist[[1]]) ## [1] TRUE This also means that [ is used to slice a list (into another list), while [[ is used to extract single element within a list. Both support the use of character vectors to select by names: alist &lt;- list(integers=1:3, foobar=c(&quot;foo&quot;, &quot;bar&quot;), pf=paste, another_list=list(letters, month.abb)) names(alist) ## [1] &quot;integers&quot;     &quot;foobar&quot;       &quot;pf&quot;           &quot;another_list&quot; alist[c(&quot;foobar&quot;)] # a list (of length 1) ## $foobar ## [1] &quot;foo&quot; &quot;bar&quot; alist[[&quot;foobar&quot;]]  # a character vector ## [1] &quot;foo&quot; &quot;bar&quot; There is another special operator for list: the $ extractor. It serves the same purpose as [[ that it can be used to extract single element in a list by name, but in this case a variable (a symbol) rather than a character is used: identical(alist$foobar, alist[[&quot;foobar&quot;]]) ## [1] TRUE   4.2.2 Data Frame One important extension of list is data.frame, a table data structure to represent tabular data. A data.frame is indeed a list, with additional attributes. DF &lt;- data.frame(a=1:3, b=letters[1:3]) str(DF) ## &#39;data.frame&#39;:    3 obs. of  2 variables: ##  $ a: int  1 2 3 ##  $ b: Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3 class(DF)   # the abstract type (in OOP sense) ## [1] &quot;data.frame&quot; typeof(DF)  # the storage type ## [1] &quot;list&quot; A data.frame can be thought of as a list with elements sharing exactly the same length. Useful operation on data.frame includes:  sort: using order join: using merge append: using rbind or cbind aggregate: using by, aggregate, or ave pivot: using reshape partition: using split  Each operation above worth a considerable space to elaborate but since there is a overall better solution to model tabular data in R: the data.table package, the details are left for readers to explore on their own.    4.3 Special Values  4.3.1 NA The not applicable value in R, usually means missing value. NA is more complicated than its first seen. There are actually different types of NA: typeof(NA) ## [1] &quot;logical&quot; typeof(NA_character_) ## [1] &quot;character&quot; typeof(NA_integer_) ## [1] &quot;integer&quot; typeof(NA_real_) ## [1] &quot;double&quot; Most time one uses NA in general, and let the R language to deal with the casting: c(&quot;foo&quot;, &quot;bar&quot;, NA) # the NA is indeed a character type ## [1] &quot;foo&quot; &quot;bar&quot; NA c(1:3, NA)          # here NA is typed integer ## [1]  1  2  3 NA Many operation can result in missing value. For example, to subset using out-of-range index: letters[26:27] # there is no 27th alphabet in English! ## [1] &quot;z&quot; NA   4.3.2 NaN NaN means “not a number.” The value results from mathematic operation that results in un-defined value, say: 0/0   ## [1] NaN Also notice that 1/0 results in Inf and -1/0 results in -Inf.   4.3.3 NULL NULL is another special value: it means nothing. Do not confuse it with NA. NULL means nothing so it does not have length: length(NULL) ## [1] 0 length(NA) ## [1] 1    "],
["control.html", "Chapter 5 Control Flow 5.1 Conditioning 5.2 Loop", " Chapter 5 Control Flow  5.1 Conditioning  5.1.1 if The if statement (a function indeed) can handle conditional branching of the codes. It can be followed by optional else if and else branches. if ( TRUE ) {   print(&quot;Yes it is true.&quot;) } else if ( TRUE ) {   print(&quot;This is never printed.&quot;) } else {   print(&quot;When nothing above holds, this is printed.&quot;) } ## [1] &quot;Yes it is true.&quot; Notice that when else if exists, conditions are checked in order. The first matched branch will be executed and all the other dsicarded. This is why the second branch is never triggered in the above example even if the condition is TRUE as well. The condition in if can not handle logical vectors with length more than one. In the following example, a warning will be issued with the result clearly explained. if ( c(TRUE, FALSE) ) {   1 + 1 } ## Warning in if (c(TRUE, FALSE)) {: the condition has length &gt; 1 and only the ## first element will be used ## [1] 2 This is why sometimes people think there does exist scalar variable in R. But the truth is that everything is in vector form. There is a more functional way of using if. Consider this example: # set.seed(777) cond &lt;- sample(1:10, 1) res &lt;- if ( cond &gt; 5 ) &quot;foo&quot; else &quot;bar&quot; res ## [1] &quot;bar&quot; The above code is stochastic due to sample without a fixed seed. Here one directly asign the result of an if to a variable. Such syntax only works in functional language. It works because if is a function, and a function should always return something–here evaluation of the last expression of if is the returned value of it. When the conditioning is more complicated, a recommended indent style may look like: # set.seed(777) cond &lt;- sample(1:10, 1) res &lt;-    if ( cond &gt; 5 ) {     message(&quot;cond is &quot;, cond, &quot;: go if&quot;)     &quot;foo&quot;    } else {     message(&quot;cond is &quot;, cond, &quot;: go else&quot;)     &quot;bar&quot;   } ## cond is 9: go if res ## [1] &quot;foo&quot;   5.1.2 ifelse There is a vectorized version of if: the ifelse function. Now it accepts a vector of any length: vec_cond &lt;- sample(1:10, 10, replace=TRUE) &gt; 5 ifelse(sample(1:10, 10, replace=TRUE) &gt; 5, 1:10, -(1:10)) ##  [1]   1  -2  -3  -4   5  -6  -7   8  -9 -10 Notice that the call to sample results in a vector of length 10, the second argument is a vector when the condition holds, and the third for condition not holds. What happen if the vector lengths are different? Recycling will occur. See section 7.3 for more details about recycling.   5.1.3 Logical Operations There are in general two types of logical operators in R. The single form (like &amp;, |) and the double form (like &amp;&amp; annd ||). The former is vectorized, i.e., element-wise operator, and the latter is scalar-like: only the first element is processed. To see things clear: c(TRUE, FALSE, FALSE) &amp; -1:1  ## [1]  TRUE FALSE FALSE c(TRUE, FALSE, FALSE) &amp;&amp; -1:1  ## [1] TRUE Users who are familiar with other programming language may feel confused because in most general-purposed language only the double form is used as logical operator and the single form is used to perform bit-wise operation. In the R language this is simply not true. The single form serves both as bit-wise and also vectorized logical operator. Use xor for vectorized logical AND bit-wise XOR operator. One should also note that there is implicit casting (or coercion) happening in the above example. Numeric vectors are coerced into logical ones before a logical operation actually takes place.    5.2 Loop  5.2.1 repeat To repeat a code chunk, use repeat. Since there is no conditioning in repeat, usually users must also specify a conditonal break by if to avoid an infinite loop. cnt &lt;- 0 repeat {   print(&quot;Hello World!&quot;)   cnt &lt;- cnt + 1   if ( cnt &gt;= 5 )     break } ## [1] &quot;Hello World!&quot; ## [1] &quot;Hello World!&quot; ## [1] &quot;Hello World!&quot; ## [1] &quot;Hello World!&quot; ## [1] &quot;Hello World!&quot;   5.2.2 while The while loop is another common control flow available in most programming language. It accepts a condition and as long as the condition holds the code chunk will repeat. The condition is checked at the very begining of each run. cnt &lt;- 0 while ( cnt &lt; 5 ) {   print(&quot;Hello while!&quot;)   cnt &lt;- cnt + 1 } ## [1] &quot;Hello while!&quot; ## [1] &quot;Hello while!&quot; ## [1] &quot;Hello while!&quot; ## [1] &quot;Hello while!&quot; ## [1] &quot;Hello while!&quot; There is no “until” loop in R. One can use repeat to implement an “until” function. Also a while ( TRUE ) implementation can be readily replaced with repeat.   5.2.3 for Another must-have loop structure is the for loop. It implements iteration operations. The basic syntax of for would look like: for ( i in 1:5 )   print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Remember that one can use if functionally. That is, we cab asign the returned value of a if to a variable. Is that also true for for? Consider the following codes: res &lt;- for ( i in 1:10 ) i res ## NULL i ## [1] 10 Oops! the variable res has a value of NULL, not a value of the last evaluated i (which shall be 10). Does this mean that for is not a function? No. Every operation in R is a function call. if is a function. for is a function. But for is a function that will return NULL by default and that is not alterable. More interesting, for actually returns NULL invisibly, so one won’t get a NULL printed to the console everytime when a for is done. Iterating over numbers is not all what for can do. Basically a for can iterate on any vector, atomic or recursive. This is powerful and is often ignored by beginners. a &lt;- rnorm(100) b &lt;- runif(100) for ( l in list(a,b) )   print(mean(l)) ## [1] 0.2140805 ## [1] 0.4672105 All vectors can be iterated. What about a matrix? Remember that a matrix is simply an atomic vector with a dim attribute. So surely it can be iterated: (only for illustration purpose because such scenario is rarely practical) for ( i in matrix(1:4,2,2) ) print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 for is useful. But don’t use for for large-sized iteration. The overhead of for is usually quite high and since most basic operations in R are vectorzied, one should consider vectorizing in the first place when developing scripts. The following somewhat silly coding illustrates the basic difference in performance when vectorization is available: tt &lt;- vv &lt;- kk &lt;- integer(1e5) system.time(for ( i in 1:length(tt) ) vv[i] &lt;- tt[i] + 1) ##    user  system elapsed  ##    0.16    0.00    0.15 system.time(kk &lt;- tt + 1) ##    user  system elapsed  ##       0       0       0 identical(vv, kk) ## [1] TRUE To understand more, see the section 7.2.    "],
["func.html", "Chapter 6 Function 6.1 User-Define Function 6.2 Arguemnts 6.3 Anonymous Function (Lambda) 6.4 Lexical Scoping 6.5 Extraction Function 6.6 Replacement Function", " Chapter 6 Function Functions are very important in the R language because R is mostly a functional language. Indeed, every operation ever happens is a function call. This may not be easily seen in the first place. But while one types something like: 1 + 1 ## [1] 2 what really happens is a function call to the add function (see ?&quot;+&quot;). The expression is a sugar: this is the usual way human beings write down a mathematical expression. The functional way of such expression would be more like this one: `+`(1, 1) ## [1] 2 This fact holds not only for +, but also other operators like -, *, /, &gt;, &lt;, and =. Indeed these so-called “operators” are just functions. Control flows are also functions (see ?&quot;if&quot;). Indeed, even { and [ are functions. Functions are objects in R. So they can be manipulated in the way objects can be. Let’s do some impractical but potentially inspiring coding: for ( op in c(`+`, `-`, `*`, `/`) )   print(op(10, 2)) ## [1] 12 ## [1] 8 ## [1] 20 ## [1] 5 Functions are objects. And objects can be asigned. Here one asigns a function to another variable and use that variable to call the function. Another question in hand: is c(`+`, `-`, `*`, `/`) an atomic vector or recursive one? There is no function-typed aotomic vector. So even if the elements are all function (indeed, builtin), the resulting concatenation is a list.  6.1 User-Define Function A function can be created using the function function. f &lt;- function() {} In the aboce one liner a function f that does nothing is defined. A function can be called when suffixed with parantheiss (): f() ## NULL Notice that a NULL is return even if the function definition didn’t do it explicitly. Functions should always return something. NULL is that something, for acutally nothing. To explicitly return a value in a function definition, one can use the return function: f &lt;- function() {   return(1) } f() ## [1] 1 It is important to understand that a return is an exit point for a function. It signals the function to end its task. So consider the following function definition: f &lt;- function() {   print(0)   return(1)   print(2) } f() ## [1] 0 ## [1] 1 The number 2 will never be printed because there is a return before it. One don’t need a return to return values in a function. When there is no explicit return, a function will return its last-evaluated value: f &lt;- function() {   1 + 1   2 + 2 } f() ## [1] 4 So why bothering use the return? It can be handy if one expects a function to exit in an early point by some conditioning: f &lt;- function() {   if ( sample(c(TRUE, FALSE), 1) ) {     print(&quot;No Luck.&quot;)     return(NULL)       }   print(&quot;Do things...&quot;)   1 + 1   2 + 2 } for ( i in 1:5 ) { f() } ## [1] &quot;No Luck.&quot; ## [1] &quot;Do things...&quot; ## [1] &quot;No Luck.&quot; ## [1] &quot;Do things...&quot; ## [1] &quot;Do things...&quot; The above function may randomly exit.   6.2 Arguemnts A function can have arguemnts. Returned values are output of a function, arguments are input. Both are optional in coding but jusy the former will be implicitly set. To use arguments in a function, just name it in the definition: f &lt;- function(x, y) x # { is ignored if the body is one-lined identical(f(1), f(2, x=1)) ## [1] TRUE Several things worth noting:  There can be many arguments Arguments are not typed: just as all other variables in R Arguments can bve supplied by position or by name Arguments that are not used are not checked at all (so can be missing)  To access the full list of arguments within a function, one can utilize the function match.call: f &lt;- function(x, y) {   args &lt;- as.list(match.call())   str(args) } f(1, 2) ## List of 3 ##  $  : symbol f ##  $ x: num 1 ##  $ y: num 2  6.2.1 Default Value Arguments can have default valuea given in the definition. When actually supplied in the function call, the default value will be overwritten. f &lt;- function(x, y=1) {   x + y } for ( i in 1:5 ) print(f(i)) ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 for ( i in 1:5 ) print(f(10, i)) ## [1] 11 ## [1] 12 ## [1] 13 ## [1] 14 ## [1] 15   6.2.2 Lazy Evaluation Function arguments are lazily evaluated. This means that arguments are only needed when they are actually used. Consider the following example: f &lt;- function(x) x g &lt;- function(x) 1 f() ## Error in f(): argument &quot;x&quot; is missing, with no default g() ## [1] 1 Both function g and f have arguemtn x. But when calling without supplying x, only f issues an error. This is because in the g function the argument x actually takes no place. Consequently, x is not even evaluated in calling g, so there will be no error for not finding x simply due to no evaluation for x at all. This is not the case for function f.   6.2.3 Ellipsis (...) The triple-dot expression is a special argument types that can come in handy in certain circumstances. It absorbs all arguments supplied not in the pre-defined named arguments. f &lt;- function(x, ...) {   list(...) } f(a=1, b=2) ## $a ## [1] 1 ##  ## $b ## [1] 2 In the above example, the argument a and b are both not pre-specified, and they are absorbed into the ellipsis varaible that can be casted to a list for further reference. Why is this helpful? Now consider this rather sophisticated example: f &lt;- function(g, ...) {   message(&quot;Now I am going to apply the function given in g...&quot;)   g(...) }  g &lt;- function(x, y) x + y f(g, x=1, y=2) ## Now I am going to apply the function given in g... ## [1] 3 Here the function f is a wrapper for function g. Many functions in R work in this way to bring in convenient programming application: notably the apply family, just name a few.    6.3 Anonymous Function (Lambda) In all the above examples, functions are asigned to variables. Or naturally speaking, functions are named. This is, however, not necessary. Consider the following example: f &lt;- function(g) {   typeof(g) } f(function() 1 + 1) ## [1] &quot;closure&quot; What’s going on here? The function f is a function that print the result of typeof for its argument. Yes it is completely redundant and is purely created for educational purpose. The argument g can be virtaully anything. So why not a function? When one types things such as f(3) one doesn’t asign a variable the number 3 (i.e., x &lt;- 3; f(x)) so why bothering assigning a function? That’s where the anonymous function comes in place. Sometimes a function is a one-timer so it is not worth typing and assigning a variable for it. This is especailly true when using the apply family, which is explored in section 7.4. Anonymous functions are sometimes called lambda in other programming language and is a common utility in modern languages, even for languages that is not functional (e.g., Python). There is another use case when one won’t explicitly assign variable to a function, because that will be done in another function! That is, one can write a function that returns a function: f &lt;- function(x) {   if ( x == &quot;add&quot; ) {     function(y, z)       y + z   } else if ( x == &quot;mul&quot; ) {     function(y, z)       y * z   } else {     function()       NULL   } } g &lt;- f(&quot;add&quot;) # the result should be 3 identical(g(1, 2), f(&quot;add&quot;)(1, 2)) ## [1] TRUE Now the world is more functional. The f function is a factory to create different functions by its arguemnt. The return value of f is a newly created function–whatever name it is–and since the return value is a function, of course it can be called to work. Even the returned function doesn’t need to have be named or assigned, one can directly call it with () suffix.   6.4 Lexical Scoping Can a function see (or use) variables defined out sied of it? Consider the following example: y &lt;- 10 f &lt;- function(x) x + y f(1) ## [1] 11 The anwser seems to be yes. Here the variable y does not appear within the function but it does exist in the global environment. To see what variable exist in the global environment, use the ls function without arguments: ls() # list variables in the current environment ##  [1] &quot;a&quot;        &quot;A&quot;        &quot;a_vec&quot;    &quot;alist&quot;    &quot;b&quot;        &quot;B&quot;        ##  [7] &quot;baz&quot;      &quot;bazf&quot;     &quot;bazf1&quot;    &quot;bazf2&quot;    &quot;bazf3&quot;    &quot;bol_vec&quot;  ## [13] &quot;cnt&quot;      &quot;cond&quot;     &quot;DF&quot;       &quot;f&quot;        &quot;g&quot;        &quot;i&quot;        ## [19] &quot;kk&quot;       &quot;l&quot;        &quot;mm&quot;       &quot;num_vec&quot;  &quot;op&quot;       &quot;res&quot;      ## [25] &quot;ss&quot;       &quot;str_vec&quot;  &quot;tt&quot;       &quot;vec_cond&quot; &quot;vv&quot;       &quot;xf&quot;       ## [31] &quot;y&quot; Use the ls function within a function can reveal the scope of that function: y &lt;- 10 f &lt;- function(x) {   print(ls())   x + y } f(1) ## [1] &quot;x&quot; ## [1] 11 Clearly the function only has variable x defined because it is assigned in the argument. When a function can not find a variable within its own scope, it continue to search it on the upper scope: its parent environment. This is called lexical scoping. In the above case the function’s parent environment is the global environment. A function’s parent environment is the upper scope to its definition block. Since function definitions can be nested, functions’ scope is dynamic by nature. In the following first example, the scope of g function does not has variable y so it search upper environment, which is the scope of function f, and find a y then use it. While in the second example, even in the environment of f does not have variable y so g continues to search upper and hit the global environment (where the function f is defined) and find a y then use it. y &lt;- 10 f &lt;- function(x) {   y &lt;- 5 # this is searched   g &lt;- function(x) x + y   g(x) } f(1) # should be 6 ## [1] 6 y &lt;- 10 # this is searched f &lt;- function(x) {   # y &lt;- 5   g &lt;- function(x) x + y   g(x) } f(1) # should be 11 ## [1] 11   6.5 Extraction Function Everything that happens is a function call. So things like the following should be no exception. vv &lt;- 1:10 vv[1:3] ## [1] 1 2 3 The &lt;- is the assignment function, i.e., &quot;&lt;-&quot;(&quot;vv&quot;, 1:10) is what really happens in the functional style. And the second line, which is more interesting, is an extraction function of the form [&lt;- taking place. (Type ?&quot;[&lt;-&quot; to see the docuemnt to confirm it realy is it.) So the second line is equivalent to: `[`(vv, 1:3) ## [1] 1 2 3 That is not cool. Nobody writes in that (somewhat ugly?) way. So the R language provides the syntactic sugar to let users write codes in more human-readble fasion. Exactly the same logic applies to the [[ function for list.   6.6 Replacement Function Even more interesting is the replacement function: vv &lt;- 1:10 vv[1:3] &lt;- 0 vv ##  [1]  0  0  0  4  5  6  7  8  9 10 The second line really has stories. Now one knows that [ is indeed a function. An extraction function. So how come the second line works? Because one is now assigning a value to the return value of a function. Is that okay? Consider the following example: f &lt;- function(x) x f(1) &lt;- 2 ## Error in f(1) &lt;- 2: target of assignment expands to non-language object No. One CAN’T assign a value to a function call. The reason why vv[1:3] &lt;- 0 will work is because it is completely another function call: the call to the replacement function [&lt;-: vv &lt;- 1:10 `[&lt;-`(vv, 1:3, 0) ##  [1]  0  0  0  4  5  6  7  8  9 10 Replacement functions are everywhere. names&lt;- is one example, dim&lt;- is another.   "],
["char.html", "Chapter 7 R Language Characteristics 7.1 Help 7.2 Vectorization 7.3 Recycling 7.4 The apply Family", " Chapter 7 R Language Characteristics  7.1 Help Use ? to see the document of a function. One can even use ? to see the document of ?: try ?&quot;?&quot;. The document, however, sometimes does not help a lot. The target audience of R document is usually not for beginners so may contain examples or wordings that are hard to understand. If one is consulting third-party packages not included in the core R, the quality of documents are indeed varying. Some authors provides good documentation while the others doesn’t. That said, documents are only one source of help for R learners. Usually a better way is by googling and searching on stackoverflow.   7.2 Vectorization Every built-in data structure in R is of vector form. This means that many of the built-in functions that operate on these data structures actually operates on vectors. Consider the following minimal example: 1:10 + 1 ##  [1]  2  3  4  5  6  7  8  9 10 11 Yes the add (+) function is vectorized. An expereicend R user won’t write code like this: res &lt;- integer(10) for ( i in 1:10 )   res[i] &lt;- i + 1 res ##  [1]  2  3  4  5  6  7  8  9 10 11 The performance of vectorized codes and non-vectorized one can be huge: sillyAdd &lt;- function(n) {   res &lt;- integer(n)   for ( i in 1:n ) res[i] &lt;- i + 1   res } system.time(res1 &lt;- 1:1e6 + 1) ##    user  system elapsed  ##    0.03    0.00    0.03 system.time(res2 &lt;- sillyAdd(1e6)) ##    user  system elapsed  ##    1.17    0.00    1.17 identical(res1, res2) ## [1] TRUE Due to performance (in most cases) gain, one should always consider using vectorization whenever possible. One thing usually mis-understood by beginners: Are the apply family vectorized? The anwser is disppointedly a NO. apply family is a functional way (without side-effect) to write down codes intending to do loop-like tasks. They are NOT vectorization of any kind. This also means they do NOT gain any performance advantage.   7.3 Recycling Recycling usually happens when an operation involves in at least two vectors, and one is shorter than the other. Take extraction by logical vector for example: vec &lt;- 1:10 vec[c(T, F)] ## [1] 1 3 5 7 9 The logical vector c(T, F) is recycled to make sure it is as long as the vector to be extracted. Recycling often occurs without awaring users. No warning. No message. Recyclingis everywhere: 1:10 + 1 ##  [1]  2  3  4  5  6  7  8  9 10 11 Here the shorter vector (which is 1) is recycled to have length 10. To see things more clear: identical(1:10 + 1:2, 1:10 + rep(1:2, 5)) ## [1] TRUE   7.4 The apply Family The apply family is really one outstanding feature in the core of R language. Among the family, the most useful two are apply and lapply. Sometimes sapply also comes in handy.  7.4.1 apply apply will call the given function column-by-column or row-by-row, according to the MARGIN argument supplied. (mm &lt;- matrix(1:12, 4, 3)) ##      [,1] [,2] [,3] ## [1,]    1    5    9 ## [2,]    2    6   10 ## [3,]    3    7   11 ## [4,]    4    8   12 apply(mm, 1, sum) # by the 1st dimension: row ## [1] 15 18 21 24 apply(mm, 2, sum) # by the 2nd dimension: column ## [1] 10 26 42 apply use ellipsis, so it is very easy to apply functions with additional arguments: mm &lt;- matrix(1:12, 4, 3) apply(mm, 2, mean, trim=.2) # apply the trimmed mean over each column ## [1]  2.5  6.5 10.5 apply(mm, 2, paste, collapse=&#39;:&#39;) # concatenate all numbers for each column ## [1] &quot;1:2:3:4&quot;    &quot;5:6:7:8&quot;    &quot;9:10:11:12&quot; or lambdas: mm &lt;- matrix(1:12, 4, 3) apply(mm, 2, function(x) sd(x) / mean(x)) ## [1] 0.5163978 0.1986145 0.1229519 apply can also be used on data.frame in exactly the same way: str(cars) ## &#39;data.frame&#39;:    50 obs. of  2 variables: ##  $ speed: num  4 4 7 7 8 9 10 10 10 11 ... ##  $ dist : num  2 10 4 22 16 10 18 26 34 17 ... apply(cars, 2, max) ## speed  dist  ##    25   120   7.4.2 lapply and sapply lapply is a list apply, so it operates on a list. ll &lt;- list(1:10, letters) lapply(ll, length) ## [[1]] ## [1] 10 ##  ## [[2]] ## [1] 26 lapply always returns a list of the same length as its input. Sometimes it is sufficient to return only an atomic vector. Thgat’s where sapply comes in handy: sapply(ll, length) ## [1] 10 26 Most of the time the call to sapply will have the effect of a unlist(lapply(...)).    "],
["work-env.html", "Chapter 8 Working Directory 8.1 Library Search Path 8.2 Save / Load", " Chapter 8 Working Directory Use getwd to query the current working directory. To change working directory, use setwd. For Windows user, the path separator is typically the back-slash \\. But it is the escape character in R so if one would like to use back-slash it must be escaped, for example, like this: setwd(&quot;C:\\\\Users\\\\kylechung&quot;) or equivalently one could still follow *nix convention: setwd(&quot;C:/Users/kylechung&quot;) One can use the function dir to return all the files and folders under the current directory: # the content of this book&#39;s working directory dir() ##  [1] &quot;_book&quot;                  &quot;_bookdown.yml&quot;          ##  [3] &quot;_output.yml&quot;            &quot;01-installation.Rmd&quot;    ##  [5] &quot;02-cli-vs-ide.Rmd&quot;      &quot;03-data-struct.Rmd&quot;     ##  [7] &quot;04-control-flow.Rmd&quot;    &quot;05-function.Rmd&quot;        ##  [9] &quot;06-r-lang-char.Rmd&quot;     &quot;07-working-env.Rmd&quot;     ## [11] &quot;08-data-processing.Rmd&quot; &quot;09-error-handle.Rmd&quot;    ## [13] &quot;10-parallel.Rmd&quot;        &quot;11-s4.Rmd&quot;              ## [15] &quot;12-unittest.Rmd&quot;        &quot;20-references.Rmd&quot;      ## [17] &quot;book.bib&quot;               &quot;bookdown-demo.Rproj&quot;    ## [19] &quot;bookdown-demo.tex&quot;      &quot;index.Rmd&quot;              ## [21] &quot;LICENSE&quot;                &quot;packages.bib&quot;           ## [23] &quot;preamble.tex&quot;           &quot;rbasic101_main.Rmd&quot;     ## [25] &quot;README.md&quot;              &quot;samplecodes&quot;            ## [27] &quot;style.css&quot;              &quot;toc.css&quot; dir can also have an argument path pointing to whereever one would like to examine the file contents. The default value of path is ., which is the notation indicating current directory. One can also use relative path notation: .. to detnote the parent directory of current directory.  8.1 Library Search Path Use .libPaths to show the path(es) that will be searched by R. .libPaths() ## [1] &quot;C:/Users/kylechung/Documents/R/win-library/3.2&quot; ## [2] &quot;C:/Program Files/R/R-3.2.4revised/library&quot;   8.2 Save / Load Use save to save serialized .RData for one variable. Or use save.image to save the entire working environment.   "],
["process.html", "Chapter 9 Data Processing 9.1 Tabular Data 9.2 JSON 9.3 Databases", " Chapter 9 Data Processing  9.1 Tabular Data The recommended package to deal with tabular data I/O is the package data.table.  9.1.1 Read fread readLines   9.1.2 Write fwrite write.table writeLines   9.1.3 Column-Oriented Computation   9.1.4 Row-Oriented Computation   9.1.5 By-Group Operations   9.1.6 Merge   9.1.7 Reshape    9.2 JSON The recommended package to deal with json I/O is the package jsonlite.   9.3 Databases   "],
["error.html", "Chapter 10 Error Handling", " Chapter 10 Error Handling Error handling in R is functional. For beginners this might be a little bit hard to understand in the first glance. The template is as the followings: result &lt;-      tryCatch({         # main expression block         # last valuated expression will be returned in case of success     }, warning=function(cond) {         # warning handling block, wrapped in function         # argument is a condition class auto-generated in case of warning     }, error=function(cond) {         # error handling block, wrapped in function         # argument is a condition class auto-generated in case of error     }, finally={         # the finally block that always evaluated     }) Except for the first argument, which is a closure (the expr argument) enclosed by {, all the other arguments are optional. That said, tryCatch prevents the execution of the expr from stopping due to any error if the argument error is supplied. And it prevents a warning being issued if the argument warning is supplied. The finally closure, if speficied, will be executed on any condition. Consider this example: tryCatch(1 + &quot;1&quot;) ## Error in 1 + &quot;1&quot;: non-numeric argument to binary operator Error still occurs. This is because the error is NOT caught. To catch the error, one should write something like: tryCatch({   1 + &quot;1&quot; }, error=function(cond) print(&quot;The error is caught!&quot;)) ## [1] &quot;The error is caught!&quot; Now there is no error message, instead, the function specified in error argument is executed. tryCatch({   1 + &quot;1&quot;   }, error=function(cond) print(&quot;The error is caught!&quot;),   finnaly = {     print(&quot;This is printed whatsoever.&quot;)   }) ## [1] &quot;This is printed whatsoever.&quot; ## [1] &quot;The error is caught!&quot; The is also a simplied version of error handler: the try function. It is light-weighted but with less capability.  "],
["parallel.html", "Chapter 11 Parallel Computing", " Chapter 11 Parallel Computing This chapter introduces the built-in package parallel for the embarrassingly parallel computing in the R language. mclapply parLapply pvec  "],
["s4.html", "Chapter 12 Programming with S4", " Chapter 12 Programming with S4  "],
["test.html", "Chapter 13 Unit-Testing", " Chapter 13 Unit-Testing The recommended package for unit-testing is testthat.  "],
["references.html", "Chapter 14 References", " Chapter 14 References     "]
]
